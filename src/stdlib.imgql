// Copyright 2018 Vincenzo Ciancia.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
//
// A copy of the license is available in the file "Apache_License.txt".
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Prefix and infix forms for boolean operators
let &(a,b) = and(a,b)       
let |(a,b) = or(a,b)
let !(a) = not(a)

// "Through" operator in infix form; used internally to define mayReach and
// surrounded 
// a ~> b is true at point x if there is a connected component C of
// the points that are true in a, with C containing one point which is true in b 
let ~>(a,b) = through(b,a)      

// Prefix operator form for near, interior, and external boundary
let N(a) = near(a)
let I(a) = interior(a)
let B+(a) = (near(a)) \ a

// Set theoretic subtraction
let \(a,b) = and(a,not(b))

// Reachability derived operators
let mayReach(a,b) = N((b ~> N a) | a) // This is the \rho operator from TACAS19
let touch(a,b) = a ~> N b
let grow(a,b) = (a | touch(b,a))
let T(a,b) = touch(a,b)

let surrounded(a,b) = a \ mayReach(not(a | b),not(b)) 
let S(a,b) = surrounded(a,b)

// Some shorthands 
let .< (n,i) = (n .<= i) & (!(n .= i))
let .> (n,i) = (n .>= i) & (!(n .= i))
let <. (i,n) = n .> i
let <=. (i,n) = n .>= i
let >. (i,n) = n .< i
let >=. (i,n) = n .<= i
let =. (i,n) = n .= i

let .* (a,b) = b *. a
let .+ (a,b) = b +. a


// Distance operators
let pdt(x) = mask(dt(x),dt(x) >. 0)
let distgeq(x,y) = x .<= pdt(y)
let distleq(x,y) = x .>= pdt(y)

// More advanced functions
let smoothen(a,x) = distleq(x,distgeq(x,!a))

let ~ (a,b,rad,bins) = crossCorrelation(rad,a,b,tt,min(b),max(b),bins)

let booleanToNumber(k,x) = mask(constant(k),x)

let norm(k,x) = (k .* x) /. max(x)

// Poor man's ifthenelse
let ifB (cond,th,el) = 
    or(and(th,bconstant(cond)),and(el,not(bconstant(cond))))
    
let ifN (cond,th,el) =
    mask(th,bconstant(cond)) + mask(el,not(bconstant(cond)))

let maskCC(phi1,phi2) = mask(Lcc(phi2),phi1)
let minCC(phi1,phi2) = min(maskCC(phi1,phi2))
let maxCC(phi1,phi2) = max(maskCC(phi1,phi2))

let collect(phi1,phi2) = // Collective operator: M,X |= phi1 -< Gr phi2
    (vol(phi1) .=. 0) | ((minCC(phi1,phi2) .=. maxCC(phi1,phi2)) & (maxCC(phi1,phi2) .>. 0))
    
let emptyB(phi) = volume(phi) .=. 0
let nemptyB(phi) = volume(phi) .>. 0

let xor(phi1,phi2) = (phi1 & !phi2) | (phi2 & !phi1)
let eqB(phi1,phi2) = emptyB(xor(phi1,phi2))
let neqB(phi1,phi2) = nemptyB(xor(phi1,phi2))
let leqB(phi1,phi2) = emptyB(phi1 & !phi2)

let overlayB(boolean,maskfalse,masktrue) =
    mask(masktrue,boolean) + mask(maskfalse,!boolean)

let overlayColor(boolean,img,r,g,b) =
    rgb(overlayB(boolean,red(img),constant(r)),overlayB(boolean,green(img),constant(g)),overlayB(boolean,blue(img),constant(b)))

// divZ(i1,i2,i3) 
// for each voxel[v], this is equal to i1[v] / i2[v] if i2[v] is different than 0, and it is equal to i3[v] otherwise


let divZ(i1,i2,i3) = 
    mask((i1 / mask(constant(1),!(i2 =. 0))),!(i2 =. 0)) + (mask(i3,i2 =. 0))

let erode(a,x) = !(distleq(x,!a))//distgeq(x,!a) // == !(distleq(x,!a))
let dilate(a,x) = distleq(x,a)
let imopen(a,x) = dilate(erode(a,x),x) //eliminates elements <x
let imclose(a,x) = erode(dilate(a,x),x) //close holes <x

